# 적 재구현 계획 (EnemyAIController / AttackWarningComponent / CharacterEnemy)

이 문서는 `EnemyAIController`, `AttackWarningComponent`, `CharacterEnemy` 클래스를 삭제한 뒤에도 **새 대화에서 동일 기능을 다시 구현**할 수 있도록, 현재 프로젝트(`D:\github\ue5-simplebattle`)의 동작을 기준으로 **재구현에 필요한 구조/값/흐름**을 정리한 계획서입니다.

## 목표 동작 (현재 구현 기준)

- 게임 시작 시 테스트용 적 1마리가 스폰된다.
  - 스폰 위치/회전은 `SimpleGameMode`에서 고정값으로 스폰한다.
- 적은 코드 기반 AI 컨트롤러에 의해 상태를 순환한다.
  - `Idle(대기)` -> `Moving(플레이어 추적 이동)` -> `AttackWarning(공격 경고 데칼 표시)` -> `Idle`
- 경고 단계에서 적은 **플레이어를 바라보도록 회전 보간**한다.
- 경고 데칼은 적 전방 바닥에 **빨간 직사각형 데칼**로 표시되며, 표시될 때 **전방 방향으로 wipe reveal 애니메이션**이 진행된다.

## 관련 파일/클래스 맵

- 적 캐릭터
  - `SimpleBattle/Source/SimpleBattle/Public/Character/CharacterEnemy.h`
  - `SimpleBattle/Source/SimpleBattle/Private/Character/CharacterEnemy.cpp`
  - 클래스: `ACharacterEnemy : public ACharacter`
- 적 AI 컨트롤러
  - `SimpleBattle/Source/SimpleBattle/Public/AI/EnemyAIController.h`
  - `SimpleBattle/Source/SimpleBattle/Private/AI/EnemyAIController.cpp`
  - 클래스: `AEnemyAIController : public AAIController`
  - 상태 enum: `EEnemyState { Idle, Moving, AttackWarning }`
- 공격 경고 컴포넌트
  - `SimpleBattle/Source/SimpleBattle/Public/Component/AttackWarningComponent.h`
  - `SimpleBattle/Source/SimpleBattle/Private/Component/AttackWarningComponent.cpp`
  - 클래스: `UAttackWarningComponent : public UActorComponent`
  - 런타임 생성 컴포넌트: `UDecalComponent`
- (의존) 외형 컴포넌트: 적/플레이어가 공통으로 사용
  - `SimpleBattle/Source/SimpleBattle/Public/Component/StaticMeshAppearanceComponent.h`
  - `SimpleBattle/Source/SimpleBattle/Private/Component/StaticMeshAppearanceComponent.cpp`
  - 클래스: `UStaticMeshAppearanceComponent`
  - 적 재구현 범위는 아니지만 `ACharacterEnemy`가 생성/사용한다.

## 모듈 의존성 (Build.cs)

- `SimpleBattle/Source/SimpleBattle/SimpleBattle.Build.cs`
  - `PublicDependencyModuleNames`에 `AIModule` 포함이 필요
  - 현재는 이미 포함되어 있음: `"Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "AIModule"`

## ACharacterEnemy 재구현 상세

### 책임

- 적 Pawn/Character로서 AIController를 지정하고, 필요한 컴포넌트를 생성한다.
- 경고 표시를 위한 API를 `AEnemyAIController`가 호출할 수 있게 제공한다.

### 클래스/멤버 (헤더 요약)

- forward decl:
  - `class UStaticMeshAppearanceComponent;`
  - `class UAttackWarningComponent;`
- 멤버:
  - `TObjectPtr<UStaticMeshAppearanceComponent> AppearanceComp;` (`VisibleAnywhere`, Category `"Appearance"`)
  - `TObjectPtr<UAttackWarningComponent> AttackWarningComp;` (`VisibleAnywhere`, Category `"AttackWarning"`)
- 메서드:
  - `ACharacterEnemy();`
  - `void ShowAttackWarning();`
  - `void HideAttackWarning();`
  - `virtual void BeginPlay() override;`

### 생성자 동작 (cpp 로직)

- Tick 비활성:
  - `PrimaryActorTick.bCanEverTick = false;`
- AI 컨트롤러/오토 포제스:
  - `AIControllerClass = AEnemyAIController::StaticClass();`
  - `AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;`
- 이동 설정:
  - `bUseControllerRotationYaw = false;`
  - `GetCharacterMovement()->bOrientRotationToMovement = true;`
  - `GetCharacterMovement()->RotationRate = FRotator(0.f, 360.f, 0.f);`
  - `GetCharacterMovement()->MaxWalkSpeed = 300.f;`
- 컴포넌트 생성:
  - `AppearanceComp = CreateDefaultSubobject<UStaticMeshAppearanceComponent>(TEXT("Appearance"));`
  - `AttackWarningComp = CreateDefaultSubobject<UAttackWarningComponent>(TEXT("AttackWarning"));`

### BeginPlay 동작

- 외형 색상 빨강으로 설정:
  - `AppearanceComp->SetColor(FLinearColor(0.9f, 0.1f, 0.1f));`

### 경고 API

- `ShowAttackWarning()` -> `AttackWarningComp->ShowWarning()`
- `HideAttackWarning()` -> `AttackWarningComp->HideWarning()`

## AEnemyAIController 재구현 상세

### 책임

- 단순 상태 머신으로 적을 제어한다.
  - Idle: 일정 시간 대기 후 Moving으로 전환
  - Moving: 플레이어를 향해 `MoveToActor`로 이동, 공격 범위에 들어오면 정지하고 AttackWarning으로 전환
  - AttackWarning: 경고 데칼을 보여주고 플레이어를 바라보며 WarningDuration 후 Idle로 복귀

### 헤더 구조

- `UENUM() enum class EEnemyState : uint8 { Idle, Moving, AttackWarning };`
- 클래스 멤버:
  - `EEnemyState CurrentState = EEnemyState::Idle;`
  - `UPROPERTY() TObjectPtr<ACharacterEnemy> EnemyCharacter;`
  - `FTimerHandle StateTimerHandle;`
- 튜닝 값 (`EditAnywhere`, Category `"AI|Tuning"`):
  - `float IdleDuration = 2.5f;`
  - `float AttackRange = 400.f;`
  - `float WarningDuration = 1.5f;`
- 상태 전환/헬퍼:
  - `EnterIdle()`, `EnterMoving()`, `EnterAttackWarning()`
  - `OnIdleTimerExpired()`, `OnWarningTimerExpired()`
  - `FacePlayer(float DeltaTime)`
  - `ACharacter* GetPlayerCharacter() const` (플레이어 0번 반환)

### cpp 핵심 로직

#### 생성자

- `PrimaryActorTick.bCanEverTick = true;`

#### OnPossess

1. `EnemyCharacter = Cast<ACharacterEnemy>(InPawn);`
2. 캐스트 실패 시 Warning 로그 후 리턴
3. 성공 시 `EnterIdle()` 진입

#### Tick

- `EnemyCharacter` 없으면 리턴
- `CurrentState` 분기:
  - `Moving`:
    - `Player = GetPlayerCharacter()`
    - 거리 `Distance = Dist(EnemyCharacter.Location, Player.Location)`
    - `Distance <= AttackRange`이면:
      - `StopMovement()`
      - `EnterAttackWarning()`
  - `AttackWarning`:
    - `FacePlayer(DeltaTime)`로 계속 회전
  - 그 외: 아무 것도 안 함

#### EnterIdle

- `CurrentState = Idle`
- Timer:
  - `SetTimer(StateTimerHandle, this, OnIdleTimerExpired, IdleDuration, false)`

#### EnterMoving

- `CurrentState = Moving`
- `Player` 있으면:
  - `MoveToActor(Player, AttackRange * 0.8f);`
    - acceptance radius로 `AttackRange`의 80% 사용
- `Player` 없으면 `EnterIdle()`로 복귀

#### EnterAttackWarning

- `CurrentState = AttackWarning`
- `EnemyCharacter->ShowAttackWarning();`
- Timer:
  - `SetTimer(StateTimerHandle, this, OnWarningTimerExpired, WarningDuration, false)`

#### OnWarningTimerExpired

- `EnemyCharacter->HideAttackWarning();`
- `EnterIdle();`

#### FacePlayer

- 플레이어 방향 벡터 `Direction = Player - Enemy`, `Direction.Z = 0`
- `RInterpTo(CurrentRotation, TargetRotation, DeltaTime, 10.f)`로 회전 보간 후 `SetActorRotation`

#### GetPlayerCharacter

- `UGameplayStatics::GetPlayerCharacter(GetWorld(), 0)`

## UAttackWarningComponent 재구현 상세

### 책임

- 오너 액터 전방 바닥에 직사각형 `UDecalComponent`를 런타임 생성/부착한다.
- `ShowWarning()` 호출 시 데칼을 표시하고, `RevealProgress` 스칼라 파라미터를 0->1로 올리며 wipe 애니메이션을 수행한다.
- `HideWarning()` 호출 시 즉시 숨기고 애니메이션을 중단한다.

### 헤더 구조/기본값 (UPROPERTY)

- Shape:
  - `WarningLength = 500.f` (전방 길이)
  - `WarningWidth = 150.f`
  - `ForwardOffset = 250.f`
  - `ProjectionDepth = 200.f`
- Animation:
  - `WipeAnimDuration = 0.4f`
- Material:
  - `UMaterialInterface* DecalMaterialOverride` (null이면 기본 머티리얼 생성)
- 내부:
  - `UDecalComponent* DecalComp` (UPROPERTY)
  - `UMaterialInstanceDynamic* DynamicMaterial` (UPROPERTY)
  - `bool bIsWipeAnimating`, `float WipeProgress`

### BeginPlay

- `CreateDecalComponent()` 호출

### TickComponent (wipe 애니메이션)

- 조건: `bIsWipeAnimating && DynamicMaterial`
- `WipeProgress += DeltaTime / WipeAnimDuration`
- 1.0 도달 시 clamp 및 `bIsWipeAnimating = false`
- `DynamicMaterial->SetScalarParameterValue("RevealProgress", WipeProgress)`

### ShowWarning

1. `DecalComp->DecalSize = FVector(ProjectionDepth, WarningWidth*0.5f, WarningLength*0.5f)`
2. `DecalComp->SetRelativeLocation(FVector(ForwardOffset, 0, 0))`
3. `WipeProgress = 0`, `bIsWipeAnimating = true`
4. `DynamicMaterial` 있으면 `RevealProgress = 0`
5. `DecalComp->SetVisibility(true)`

### HideWarning

- `DecalComp->SetVisibility(false)`
- `bIsWipeAnimating = false`
- `WipeProgress = 0`

### CreateDecalComponent (런타임 생성/부착)

- `Owner = GetOwner()` 없으면 리턴
- `DecalComp = NewObject<UDecalComponent>(Owner, ..., MakeUniqueObjectName(..., "AttackWarningDecal"))`
- `DecalComp->SetupAttachment(Owner->GetRootComponent())`
- `DecalComp->DecalSize = FVector(ProjectionDepth, WarningWidth*0.5f, WarningLength*0.5f)`
- `DecalComp->SetRelativeRotation(FRotator(-90.f, 0.f, 0.f))` (바닥 투영)
- `DecalComp->SetRelativeLocation(FVector(ForwardOffset, 0.f, 0.f))`
- 기본은 숨김: `SetVisibility(false)`
- 월드 초기화 이후면 `RegisterComponent()`
- 머티리얼:
  - override 있으면 `UMaterialInstanceDynamic::Create(DecalMaterialOverride, Owner)`
  - 없으면 `CreateDefaultMaterial()`
- 마지막으로 `DecalComp->SetDecalMaterial(DynamicMaterial)`

### CreateDefaultMaterial (프로그램 생성, wipe 구현)

- `UMaterial* ParentMat = NewObject<UMaterial>(GetTransientPackage(), "M_AttackWarning", RF_Transient)`
- 설정:
  - `MaterialDomain = MD_DeferredDecal`
  - `BlendMode = BLEND_Translucent`
  - `DecalBlendMode = DBM_Stain`
- `WITH_EDITOR` 블록에서 머티리얼 그래프 구성:
  - BaseColor: `FLinearColor(0.9, 0.1, 0.05)`
  - TexCoord(0) -> ComponentMask(R) 로 U 채널 추출
  - ScalarParameter `"RevealProgress"` (default 0)
  - If 노드: `RevealProgress > U`면 Opacity `0.6`, 아니면 `0.0`
  - `PostEditChange()`
- `DynamicMaterial = UMaterialInstanceDynamic::Create(ParentMat, Owner)`
- `RevealProgress = 0`

### 주의/제약

- `CreateDefaultMaterial()`의 그래프 구성은 `#if WITH_EDITOR`에 있음.
  - 에디터(PIE)에서는 정상 동작하지만, 비에디터 빌드에서 기본 머티리얼이 기대대로 생성되지 않을 수 있음.
  - 패키징까지 고려하면 `DecalMaterialOverride`로 Content 머티리얼을 제공하거나, 런타임에서도 동작하도록 설계를 바꾸는 편이 안전함.

## 스폰/테스트 하네스 (동작 검증용)

- `SimpleBattle/Source/SimpleBattle/Private/Game/SimpleGameMode.cpp`
  - `BeginPlay()`에서 적 1개 스폰:
    - `SpawnLocation(800, 0, 100)`
    - `SpawnRotation(0, 180, 0)`
    - `SpawnCollisionHandlingOverride = AdjustIfPossibleButAlwaysSpawn`

## 재구현 체크리스트 (삭제 후 다시 만들 때)

1. 위 파일 경로에 동일한 클래스/이름으로 `.h/.cpp` 생성
2. `CharacterEnemy.cpp`에서 컴포넌트 생성/이동 설정/AIControllerClass 지정
3. `EnemyAIController`에서:
   - `OnPossess` 캐시 + `EnterIdle()`
   - `Tick`에서 Moving 거리 체크 + AttackWarning에서 FacePlayer
   - `MoveToActor(Player, AttackRange*0.8f)`와 `StopMovement()` 사용
   - 타이머로 상태 전환
4. `AttackWarningComponent`에서:
   - `BeginPlay`에 `CreateDecalComponent()`
   - `ShowWarning/HideWarning` 구현
   - `TickComponent`에서 `RevealProgress` 업데이트
   - `UDecalComponent` 런타임 생성/부착/등록 + MID 적용
5. PIE에서 동작 확인:
   - 시작 후 2.5초 대기 -> 이동 -> 400 거리 이내 진입 시 정지
   - 경고 데칼 표시 + 0.4초 wipe 진행
   - 1.5초 후 숨김 + 다시 Idle

